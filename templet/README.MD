## 图

### 最短路径

#### Dijkstra算法（单源）

[代码](./dijkstra.cpp)
本质为贪心算法，用邻接表时间复杂度O(|V|^2+2|E|)，用邻接矩阵时间复杂度为O(|V|^2+|V|^2)，因为所有节点的最短距离算出来，最外层循环次数为|V|次，在每次循环里找下一个最近的顶点需要扫描所有的节点，即|V|次。用邻接表存储时，每次更新只需要扫描选定节点的邻接点，所有循环下来，相当于一共扫描了2|E|条边。而邻接矩阵每次更新需要扫描所有的节点，大循环里又循环了|V|次。当用堆来优化时，因为堆插入和和取出最小值的时间复杂度为O(logN)[构建堆的时间复杂度为O(N)，调整堆的时间复杂度为O(logN)]。所以用邻接表+堆实现时，时间复杂度为O(|V|log|V|+2|E|log|V|)=O(|E|log|V|)，适合稀疏图。

#### Bellman-Ford（单源） 

[代码](./bellman_ford.cpp)
递推式为：d[i]=min(d[j]+cost(j,i)|(j,i)属于E)。 对于每一条边 edge(j,i)，如果d[j] +cost(j, i)< d[i]，则令d[i] =d[j]+cost(j, i)。若上述操作没有对d进行更新，说明最短路径已经查找完毕，或者部分点不可达，跳出循环。否则执行下次循环。可知，如果图中不存在从s可达的负圈，那么最短路不会经过同一个顶点两次（也就是说，最多通过|V|-1条边），外层循环最多执行|V|-1次。所以时间复杂度为O(|V| * |E|）。如果存在负圈，那么在第|V|次也会更新d的值，根据此可以检查负圈。如果把初始值d都设置为0，那么可以检测出图中所有的负圈。只设置某个点的d值为零，则只能检查从该点可达的负圈。

#### Floyd算法（多源）

[代码](./floyd.cpp)
本质为动态规划，算法复杂度为O(|V|^3)，和bellman-ford一样可以处理负边的情况，也可以根据d[i][i]是否为负数判断是否图有负圈。

题集：[poj3311](../poj/poj3311.cpp)

### 最小生成树

#### Prim算法

[代码](./prim.cpp)
让小树慢慢长大。关注节点。算法复杂度和dijkstra分析的方法相同，一般方法（邻接矩阵）是O(|V|^2)，使用堆是O(|E|log|V|)，适合稠密图

#### Kruskal算法

[代码](./kruskal.cpp)
将森林合并成树。关注边。边的排序最费时，算法复杂度为O(|E|log|E|)，适合稀疏图

题集：[poj3723](../poj/poj3723.cpp)

### 二叉树遍历

#### 前序遍历

#### 中序遍历

#### 后序遍历

## 动态规划

### 0/1背包

### 完全背包

### 多重背包

### 最长公共子序列

### 最长递增序列

### 硬币划分/划分数

题集：[uva674](../uva/uva674.cpp)

### 区间dp

题集：[uva10003](../uva/uva10003.cpp)

### 状态压缩dp

[旅行商问题](./tsp.cpp)

题集：[uva10651](../uva/uva10651.cpp) [poj3311](../poj/poj3311.cpp) [poj2686](../poj/poj2686.cpp)

## dfs

## bfs

## 数据结构

### 并查集

[代码](./union_find.cpp)
合并时优化树结构+查询时优化树结构（路径压缩），算法复杂度为O(ackermann(n))，比O(nlog(n))要快。在kruskal算法中用到。

题集：[poj3723](../poj/poj3723.cpp)

### 线段树

## 字符串

### KMP算法

## 数学相关

### 最大公约数

[代码](./代码.cpp)
辗转相除法（欧几里得算法）,算法复杂度为O(log max(x,y))

### 素数

包括素数测试、约数枚举、整数分解，均是枚举i^2<=n，算法复杂度为O(sqrt(n))

#### 埃氏筛法

[代码](./sieve.cpp) 区间内筛素数相同思想
