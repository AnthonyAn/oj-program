## 图

### 最短路径

#### Dijkstra算法（单源）

[代码](./dijkstra.cpp)
本质为贪心算法，用邻接表时间复杂度O(|V|^2+2|E|)，用邻接矩阵时间复杂度为O(|V|^2+|V|^2)，因为所有节点的最短距离算出来，最外层循环次数为|V|次，在每次循环里找下一个最近的顶点需要扫描所有的节点，即|V|次。用邻接表存储时，每次更新只需要扫描选定节点的邻接点，所有循环下来，相当于一共扫描了2|E|条边。而邻接矩阵每次更新需要扫描所有的节点，大循环里又循环了|V|次。当用堆来优化时，因为堆插入和和取出最小值的时间复杂度为O(logN)[构建堆的时间复杂度为O(N)，调整堆的时间复杂度为O(logN)]。所以用邻接表+堆实现时，时间复杂度为O(|V|log|V|+2|E|log|V|)=O(|E|log|V|)，适合稀疏图。

#### Bellman-Ford（单源） 

[代码](./bellman_ford.cpp)
递推式为：d[i]=min(d[j]+cost(j,i)|(j,i)属于E)。 对于每一条边 edge(j,i)，如果d[j] +cost(j, i)< d[i]，则令d[i] =d[j]+cost(j, i)。若上述操作没有对d进行更新，说明最短路径已经查找完毕，或者部分点不可达，跳出循环。否则执行下次循环。可知，如果图中不存在从s可达的负圈，那么最短路不会经过同一个顶点两次（也就是说，最多通过|V|-1条边），外层循环最多执行|V|-1次。所以时间复杂度为O(|V| * |E|）。如果存在负圈，那么在第|V|次也会更新d的值，根据此可以检查负圈。如果把初始值d都设置为0，那么可以检测出图中所有的负圈。只设置某个点的d值为零，则只能检查从该点可达的负圈。

#### Floyd算法（多源）

[代码](./floyd.cpp)
本质为动态规划，算法复杂度为O(|V|^3)，和bellman-ford一样可以处理负边的情况，也可以根据d[i][i]是否为负数判断是否图有负圈。

题集：[poj3311](../poj/poj3311.cpp)

### 最小生成树

#### Prim算法

[代码](./prim.cpp)
让小树慢慢长大。关注节点。算法复杂度和dijkstra分析的方法相同，一般方法（邻接矩阵）是O(|V|^2)，使用堆是O(|E|log|V|)，适合稠密图

#### Kruskal算法

[代码](./kruskal.cpp)
将森林合并成树。关注边。边的排序最费时，算法复杂度为O(|E|log|E|)，适合稀疏图

题集：[poj3723](../poj/poj3723.cpp)

### 二叉树遍历

#### 前序遍历

#### 中序遍历

#### 后序遍历

## 动态规划

### 典型题目

题集：[uva116](../uva/uva116.cpp) [uva825 计数](../uva/uva825.cpp)

### dag

[代码](./dag.cpp)
题集：[uva103](../uva/uva103.cpp) [uva10051 隐式dag](../uva/uva10051.cpp) [uva437 隐式dag](../uva/uva437.cpp) 

### 0/1背包

[代码](./dkap0_1)
题集：[uva624 考虑阶段信息回溯解](../uva/uva624.cpp) [uva10130](../uva/uva10130.cpp) [uva562 分成俩份，总价值的差值尽可能小](../uva/uva562.cpp)

注意dp数组的初始化，对应着不同的题目要求。下同

### 完全背包

题集：[uva10465 写法上稍微不一样](../uva/uva10465.cpp)

### 多重背包

### 二维背包问题

[代码](./dkap_2_dims.cpp)
题集：[uva10306](../uva/uva10306.cpp)

### 最长公共子序列

序列中元素具有某种有向联系的可以考虑lis模型求解，比如矩形嵌套，砖块堆积等

[代码](./lcs.cpp)
题集：[uva10066](../uva/uva10066.cpp) [uva10192](../uva/uva10192.cpp) [uva10069](../uva/uva10069.cpp) [uva10131 此例体会lis和lcs的联系](../uva/uva10131.cpp) [uva437](../uva/uva437.cpp) 

### 最长递增序列

[dp代码](./lis_dp.cpp) [O(nlogn)代码](./lis_best.cpp)
题集：[uva10534 这道题很巧妙](../uva/uva10534.cpp) [uva10051](../uva/uva10051.cpp) [uva10131 此例体会lis和lcs的联系](../uva/uva10131.cpp) [uva10285 此例拓展到二维](../uva/uva10285.cpp)

### 硬币划分/划分数
[代码](./divide.cpp)
题集：[uva674](../uva/uva674.cpp) [uva357](../uva/uva357.cpp)

### 区间dp

cost函数有所区别，注意初始化值。

题集：[uva10003 切木头 递归](../uva/uva10003.cpp) [uva348 矩阵链乘 dp](../uva/uva348.cpp) 

### 状态压缩dp

[旅行商问题](./tsp.cpp)

题集：[uva10651](../uva/uva10651.cpp) [poj3311](../poj/poj3311.cpp) [poj2686](../poj/poj2686.cpp)

### 游戏对弈

题集：[uva10404](../uva/uva10404.cpp)

## dfs

## bfs

## 数据结构

### 并查集

[代码](./union_find.cpp)
合并时优化树结构+查询时优化树结构（路径压缩），算法复杂度为O(ackermann(n))，比O(nlog(n))要快。在kruskal算法中用到。

题集：[poj3723](../poj/poj3723.cpp)

### 线段树

## 字符串

### KMP算法

[代码](./kmp.cpp)

题集：[leetcode28](../leetcode/leetcode28)

## 数学相关

### 最大公约数

[代码](./euclidean.cpp)
辗转相除法（欧几里得算法）,算法复杂度为O(log max(x,y))

### 素数

包括素数测试、约数枚举、整数分解，均是枚举i^2<=n，算法复杂度为O(sqrt(n))

#### 埃氏筛法

[代码](./sieve.cpp) 区间内筛素数相同思想

### 快速幂运算

[代码](./fast_pow.cpp) 递归的形式更好理解，当n为偶数时，x^n转化为(x^2)^(n/2)，当n为奇数时，x^n转化为((x^2)^(n/2))* x。每次规模减半，时间复杂度为O(logn)。

#### 矩阵的快速幂运算

[代码](./fast_matrix_pow.cpp) 利用快速幂运算的原理。