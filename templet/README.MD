## 图

### 最短路径

#### Dijkstra算法（单源）

#### Bellman-Ford（单源）

#### Floyd算法（多源）

[代码](./floyd.cpp)
本质为动态规划，算法复杂度为O(|V|^3)，和bellman-ford一样可以处理负边的情况，也可以根据d[i][i]是否为负数判断是否图有负圈。

题集：[poj3311](../poj/poj3311.cpp)

### 最小生成树

#### Prim算法

#### Kruskal算法

[代码](./kruskal.cpp)
边的排序最费时，算法复杂度为O(|E|log|V|)

题集：[poj3723](../poj/poj3723.cpp)

### 二叉树遍历

## 动态规划

### 0/1背包

### 完全背包

### 多重背包

### 最长公共子序列

### 最长递增序列

### 硬币划分/划分数

题集：[uva674](../uva/uva674.cpp)

### 区间dp

题集：[uva10003](../uva/uva10003.cpp)

### 状态压缩dp

[旅行商问题](./tsp.cpp)

题集：[uva10651](../uva/uva10651.cpp) [poj3311](../poj/poj3311.cpp)

## dfs

## bfs

## 数据结构

### 并查集

[代码](./union_find.cpp)
合并时优化树结构+查询时优化树结构（路径压缩），算法复杂度为O(ackermann(n))，比O(nlog(n))要快。在kruskal算法中用到。

题集：[poj3723](../poj/poj3723.cpp)

### 线段树

## 字符串

### KMP算法

## 数学相关

### 最大公约数

[代码](./代码.cpp)
辗转相除法（欧几里得算法）,算法复杂度为O(log max(x,y))

### 素数

包括素数测试、约数枚举、整数分解，均是枚举i^2<=n，算法复杂度为O(sqrt(n))

#### 埃氏筛法

[代码](./sieve.cpp) 区间内筛素数相同思想
